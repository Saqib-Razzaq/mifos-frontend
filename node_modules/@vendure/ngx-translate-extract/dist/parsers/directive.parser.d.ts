import { AST, LiteralPrimitive, TmplAstBoundAttribute as BoundAttribute, TmplAstElement as Element, TmplAstNode as Node, TmplAstTemplate as Template, TmplAstText as Text, TmplAstTextAttribute as TextAttribute, ParseSourceSpan } from '@angular/compiler';
import { ParserInterface } from './parser.interface.js';
import { TranslationCollection } from '../utils/translation.collection.js';
interface BlockNode {
    nameSpan: ParseSourceSpan;
    sourceSpan: ParseSourceSpan;
    startSourceSpan: ParseSourceSpan;
    endSourceSpan: ParseSourceSpan | null;
    children: Node[] | undefined;
    visit<Result>(visitor: unknown): Result;
}
export declare const TRANSLATE_ATTR_NAMES: string[];
type ElementLike = Element | Template;
export declare class DirectiveParser implements ParserInterface {
    extract(source: string, filePath: string): TranslationCollection | null;
    protected getElementsWithTranslateAttribute(nodes: Node[]): ElementLike[];
    protected getElementsWithTranslateAttributeFromBlockNodes(blockNode: BlockNode): ElementLike[];
    protected getTextNodes(element: ElementLike): Text[];
    protected hasAttributes(element: ElementLike, name: string[]): boolean;
    protected getAttribute(element: ElementLike, names: string[]): TextAttribute;
    protected hasBoundAttribute(element: ElementLike, names: string[]): boolean;
    protected getBoundAttribute(element: ElementLike, names: string[]): BoundAttribute;
    protected getLiteralPrimitives(exp: AST): LiteralPrimitive[];
    protected isElementLike(node: Node): node is ElementLike;
    protected isBlockNode(node: Node): node is BlockNode;
    protected isText(node: Node): node is Text;
    protected parseTemplate(template: string, path: string): Node[];
}
export {};
